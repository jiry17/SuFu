
Inductive List;

Point = {Int, Int};

Inductive PointList;

Plan = {PointList, PointList};

Inductive PlanList;

sqr = \x: Int. 
    * x x;

dis = \x: Point. \y: Point. 
    + (sqr (- x.1 y.1)) (sqr (- x.2 y.2));

head = \xs: PointList. 
    match xs with
      ponil _ -> {0, 0}
    | pocons {h, _} -> h
    end
;

extend = \p: Point. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> 
        let h1 = (align (label {pocons {p, (unlabel h ).1}, (unlabel h ).2} ) ) in 
            let h2 = (align (label {(unlabel h ).1, pocons {p, (unlabel h ).2}} ) ) in 
                pcons {h1, pcons {h2, f t}}
    end
);

generate = fix (
    \f: Int -> List -> PlanList. \pos: Int. \xs: List. 
    match xs with
      nil _ -> pnil Unit
    | cons {w, nil _} -> 
        let polist = (pocons {{pos, w}, ponil Unit}) in 
            pcons {let tmp1 = {polist, polist} in 
                align (label tmp1 ) , pnil Unit}
    | cons {h, t} -> 
        let res = (f (+ pos 1) t) in 
            extend {pos, h} res
    end
) 0;

eval_plist = fix (
    \f: Point -> PointList -> Int. \pre: Point. \xs: PointList. 
    match xs with
      ponil _ -> 0
    | pocons {p, t} -> + (dis p pre) (f p t)
    end
);

min = \a: Int. \b: Int. 
    if (< a b) then a
    else b;

get_best = let eval = (\p: Plan. 
    let first = (head p.1) in 
        + (eval_plist first p.1) (eval_plist first p.2)) in 
        fix (
        \f: PlanList -> Int. \xs: PlanList. 
        match xs with
          pnil _ -> 1000
        | pcons {h, t} -> min (align (eval (unlabel h )) ) (f t)
        end
    );

main = \xs: List. 
    get_best (generate xs);
