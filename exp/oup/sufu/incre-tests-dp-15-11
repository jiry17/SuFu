
List :: List. <nil Unit | cons {Int,List}>
nil : Unit -> List'. <nil Unit | cons {Int,List'}>
cons : {Int,List} -> List'. <nil Unit | cons {Int,List'}>
Schedule :: Schedule. <fin Unit | month {Int,Int,Schedule}>
fin : Unit -> Schedule'. <fin Unit | month {Int,Int,Schedule'}>
month : {Int,Int,Schedule} ->
        Schedule'. <fin Unit | month {Int,Int,Schedule'}>
Plan :: Schedule
PlanList :: PlanList. <pnil Unit | pcons {Plan,PlanList}>
pnil : Unit -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
pcons : {Plan,PlanList} ->
        PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
cost : List'. <nil Unit | cons {Int,List'}>
lim : Int
m : Int
c : Int
inf : Int
get_cost : Int -> Int
snoc : Int ->
       Int ->
       Schedule ->
       Schedule'. <fin Unit | month {Int,Int,Schedule'}>
length : List -> Int
pop_back : List -> {List, Int}
merge : PlanList -> PlanList -> PlanList
extra_cost : Int -> Int
remain : Schedule -> Int
eval : Schedule -> Int
extend : Int ->
         Int ->
         PlanList ->
         PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
generate : List -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
extra_cost : Int -> Int
remain : Schedule -> Int
eval : Schedule -> Int
min : Int -> Int -> Int
get_best : PlanList -> Int
main : List -> Int


Inductive List;

Inductive Schedule;

Plan = Compress Schedule;

Inductive PlanList;

@Input cost = cons {1, cons {1, cons {0, cons {1, cons {1, cons {0, nil Unit}}}}}};

@Input lim = 3;

@Input m = 1;

@Input c = 1;

inf = 100;

@Combine get_cost = \now: Int. 
    fix (
    \f: List -> Int -> Int. \xs: List. \i: Int. 
    match xs with
      nil _ -> inf
    | cons {h, t} -> if (== i now) then h
        else f t (+ i 1)
    end
) cost 0;

snoc = \target: Int. \w: Int. 
    fix (
    \f: Schedule -> Schedule. \xs: Schedule. 
    match xs with
      fin _ -> month {target, w, fin Unit}
    | month {a, b, t} -> month {a, b, f t}
    end
);

length = fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + 1 (f t)
    end
);

pop_back = fix (
    \f: List -> {List, Int}. \xs: List. 
    match xs with
      nil _ -> {xs, -1}
    | cons {h, nil _} -> {nil Unit, h}
    | cons {h, t} -> 
        let res = (f t) in 
            {cons {h, res.1}, res.2}
    end
);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extra_cost = \new: Int. 
    if (> new m) then * (- new m) c
    else 0;

remain = fix (
    \f: Schedule -> Int. \xs: Schedule. 
    match xs with
      fin _ -> 0
    | month {target, new, t} -> - (+ (f t) new) target
    end
);

eval = fix (
    \f: Int -> Schedule -> Int. \pre: Int. \xs: Schedule. 
    match xs with
      fin _ -> 0
    | month {target, new, t} -> 
        let remain = (- (+ pre new) target) in 
            + (f remain t) (+ (extra_cost new) (get_cost remain))
    end
) 0;

extend = \target: Int. \now: Int. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> pnil Unit
    | pcons {h, t} -> pcons {let tmp1 = (snoc target now) in 
            align (label (tmp1 (unlabel h )) ) , f t}
    end
);

generate = fix (
    \f: List -> PlanList. \xs: List. 
    match xs with
      nil _ -> pcons {let tmp2 = (fin Unit) in 
            align (label tmp2 ) , pnil Unit}
    | _ -> 
        let split = (pop_back xs) in 
            let subres = (f split.1) in 
                fix (
                \g: Int -> PlanList. \now: Int. 
                if (> now lim) then pnil Unit
                else merge (extend split.2 now subres) (g (+ now 1))            ) 0
    end
);

extra_cost = \new: Int. 
    if (> new m) then * (- new m) c
    else 0;

remain = fix (
    \f: Schedule -> Int. \xs: Schedule. 
    match xs with
      fin _ -> 0
    | month {target, new, t} -> - (+ (f t) new) target
    end
);

eval = fix (
    \f: Int -> Schedule -> Int. \pre: Int. \xs: Schedule. 
    match xs with
      fin _ -> 0
    | month {target, new, t} -> 
        let remain = (- (+ pre new) target) in 
            + (f remain t) (+ (extra_cost new) (get_cost remain))
    end
) 0;

min = \a: Int. \b: Int. 
    if (< a b) then a
    else b;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> inf
    | pcons {h, t} -> min (f t) (align (eval (unlabel h )) )
    end
);

main = \xs: List. 
    get_best (generate xs);
align term #0: compress[0] Schedule
align@0 create@0 tmp1 (unlabel h)
  h: compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>
  xs: PlanList. <pnil Unit | pcons {compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>,PlanList}>
  now: Int
  t: PlanList. <pnil Unit | pcons {compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>,PlanList}>
  target: Int
align term #1: compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>
align@1 create@0 tmp2
  xs: List. <nil Unit | cons {Int,List}>
  tmp2: Schedule. <fin Unit | month {Int,Int,Schedule}>
align term #2: Int
align@2 eval (unlabel h)
  xs: PlanList. <pnil Unit | pcons {compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>,PlanList}>
  t: PlanList. <pnil Unit | pcons {compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>,PlanList}>
  h: compress[0] Schedule. <fin Unit | month {Int,Int,Schedule}>
Components for compress:
  inf [] -> Int 8
  m [] -> Int 6
  cost [] -> List. <nil Unit | cons {Int,List}> 4
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  lim [] -> Int 5
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  c [] -> Int 7
  fin [Bot] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 1
  month [(Int * Int * Schedule. <fin Unit | month {Int,Int,Schedule}>)] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 1
  extra_cost [Int] -> Int 19
  min [Int,Int] -> Int 22

Components for align:
  inf [] -> Int 8
  eval [Schedule. <fin Unit | month {Int,Int,Schedule}>] -> Int 21
  m [] -> Int 6
  cost [] -> List. <nil Unit | cons {Int,List}> 4
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  lim [] -> Int 5
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  c [] -> Int 7
  fin [Bot] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 1
  month [(Int * Int * Schedule. <fin Unit | month {Int,Int,Schedule}>)] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 1
  snoc [Int,Int,Schedule. <fin Unit | month {Int,Int,Schedule}>] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 10
  length [List. <nil Unit | cons {Int,List}>] -> Int 11
  extra_cost [Int] -> Int 19
  get_cost [Int] -> Int 9
  remain [Schedule. <fin Unit | month {Int,Int,Schedule}>] -> Int 20
  pop_back [List. <nil Unit | cons {Int,List}>] -> (List. <nil Unit | cons {Int,List}> * Int) 12
  min [Int,Int] -> Int 22

Components for comb:
  inf [] -> Int 8
  m [] -> Int 6
  cost [] -> List. <nil Unit | cons {Int,List}> 4
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  lim [] -> Int 5
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  c [] -> Int 7
  fin [Bot] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 1
  month [(Int * Int * Schedule. <fin Unit | month {Int,Int,Schedule}>)] -> Schedule. <fin Unit | month {Int,Int,Schedule}> 1
  extra_cost [Int] -> Int 19
  min [Int,Int] -> Int 22

