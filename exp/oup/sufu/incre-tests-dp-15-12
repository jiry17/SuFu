
Player :: {Int, Int}
List :: List. <nil Unit | cons {Player,List}>
nil : Unit -> List'. <nil Unit | cons {Player,List'}>
cons : {Player,List} -> List'. <nil Unit | cons {Player,List'}>
NList :: NList. <nnil Unit | ncons {List,NList}>
nnil : Unit -> NList'. <nnil Unit | ncons {List,NList'}>
ncons : {List,NList} -> NList'. <nnil Unit | ncons {List,NList'}>
Plan :: List
PlanList :: PlanList. <pnil Unit | pcons {Plan,PlanList}>
pnil : Unit -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
pcons : {Plan,PlanList} ->
        PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
merge : PlanList -> PlanList -> PlanList
extend : Player -> PlanList -> PlanList
lim : Int
generate : NList ->
           PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
max : Int -> Int -> Int
get_best : PlanList -> Int
main : NList -> Int


Player = {Int, Int};

Inductive List;

Inductive NList;

Plan = Compress List;

Inductive PlanList;

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extend = \p: Player. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {align (label (cons {p, unlabel h }) ) , f t}
    end
);

@Input lim = Int;

generate = fix (
    \f: NList -> PlanList. \xs: NList. 
    match xs with
      nnil _ -> pcons {let tmp1 = (nil Unit) in 
            align (label tmp1 ) , pnil Unit}
    | ncons {players, remains} -> 
        let res = (f remains) in 
            fix (
            \g: List -> PlanList. \ys: List. 
            match ys with
              nil _ -> pnil Unit
            | cons {h, t} -> merge (extend h res) (g t)
            end
        ) players
    end
);

max = \a: Int. \b: Int. 
    if (< a b) then b
    else a;

get_best = let sumw = (fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {p, t} -> + p.1 (f t)
    end
)) in 
        let sumv = (fix (
        \f: List -> Int. \xs: List. 
        match xs with
          nil _ -> 0
        | cons {p, t} -> + p.2 (f t)
        end
    )) in 
            fix (
            \f: PlanList -> Int. \xs: PlanList. 
            match xs with
              pnil _ -> 0
            | pcons {h, t} -> if (<= (align (sumw (unlabel h )) ) lim) then max (align (sumv (unlabel h )) ) (f t)
                else f t
            end
        );

main = \xs: NList. 
    get_best (generate xs);
align term #0: compress[0] List. <nil Unit | cons {{Int,Int},List}>
align@0 create@0 cons ({p,unlabel h})
  p: {Int,Int}
  h: compress[0] List. <nil Unit | cons {{Int,Int},List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
align term #1: compress[0] List. <nil Unit | cons {{Int,Int},List}>
align@1 create@0 tmp1
  tmp1: List. <nil Unit | cons {{Int,Int},List}>
  xs: NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}>
align term #2: Int
align@2 sumw (unlabel h)
  h: compress[0] List. <nil Unit | cons {{Int,Int},List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
align term #3: Int
align@3 sumv (unlabel h)
  h: compress[0] List. <nil Unit | cons {{Int,Int},List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
Components for compress:
  max [Int,Int] -> Int 9
  cons [((Int * Int) * List. <nil Unit | cons {{Int,Int},List}>)] -> List. <nil Unit | cons {{Int,Int},List}> 1
  nnil [Bot] -> NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}> 2
  ncons [(List. <nil Unit | cons {{Int,Int},List}> * NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}>)] -> NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}> 2
  nil [Bot] -> List. <nil Unit | cons {{Int,Int},List}> 1

Components for align:
  max [Int,Int] -> Int 9
  cons [((Int * Int) * List. <nil Unit | cons {{Int,Int},List}>)] -> List. <nil Unit | cons {{Int,Int},List}> 1
  nnil [Bot] -> NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}> 2
  ncons [(List. <nil Unit | cons {{Int,Int},List}> * NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}>)] -> NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}> 2
  nil [Bot] -> List. <nil Unit | cons {{Int,Int},List}> 1

Components for comb:
  max [Int,Int] -> Int 9
  cons [((Int * Int) * List. <nil Unit | cons {{Int,Int},List}>)] -> List. <nil Unit | cons {{Int,Int},List}> 1
  nnil [Bot] -> NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}> 2
  ncons [(List. <nil Unit | cons {{Int,Int},List}> * NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}>)] -> NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}> 2
  nil [Bot] -> List. <nil Unit | cons {{Int,Int},List}> 1

align term #0: compress[0] List. <nil Unit | cons {{Int,Int},List}>
align@0 create@0 cons ({p,unlabel h})
  p: {Int,Int}
  h: compress[0] List. <nil Unit | cons {{Int,Int},List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
align term #1: compress[0] List. <nil Unit | cons {{Int,Int},List}>
align@1 create@0 tmp1
  tmp1: List. <nil Unit | cons {{Int,Int},List}>
  xs: NList. <nnil Unit | ncons {List. <nil Unit | cons {{Int,Int},List}>,NList}>
align term #2: Int
align@2 sumw (unlabel h)
  h: compress[0] List. <nil Unit | cons {{Int,Int},List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
align term #3: Int
align@3 sumv (unlabel h)
  h: compress[0] List. <nil Unit | cons {{Int,Int},List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {{Int,Int},List}>,PlanList}>
num = 0
start: start
node: start
  Compress[0] List. <nil Unit | cons {{Int,Int},List}>([Param0,Param1,Param2,Param3,Param4]@Compress[0] List. <nil Unit | cons {{Int,Int},List}>)
  Int([Param0,Param1,Param2,Param3,Param4]@Int)
node: [Param0,Param1,Param2,Param3,Param4]@Compress[0] List. <nil Unit | cons {{Int,Int},List}>
  Param1
node: [Param0,Param1,Param2,Param3,Param4]@Int
  Param4
  +([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
  -([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
  0
  1
  access0([Param0,Param1,Param2,Param3,Param4]@(Int * Int))
  access1([Param0,Param1,Param2,Param3,Param4]@(Int * Int))
node: [Param0,Param1,Param2,Param3,Param4]@(Int * Int)
  Param0
  prod([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
num = 1
start: start
node: start
  Int([Param0,Param1,Param2]@Int)
node: [Param0,Param1,Param2]@Int
  Param2
  +([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  -([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  0
  1
num = 2
start: start
node: start
  Compress[0] List. <nil Unit | cons {{Int,Int},List}>([Param0,Param1,Param2,Param3]@Compress[0] List. <nil Unit | cons {{Int,Int},List}>)
  Int([Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Int
  Param3
  +([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  -([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  0
  1
  max([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Compress[0] List. <nil Unit | cons {{Int,Int},List}>
  Param0
num = 3
start: start
node: start
  Compress[0] List. <nil Unit | cons {{Int,Int},List}>([Param0,Param1,Param2,Param3]@Compress[0] List. <nil Unit | cons {{Int,Int},List}>)
  Int([Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Int
  Param3
  +([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  -([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  0
  1
  max([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Compress[0] List. <nil Unit | cons {{Int,Int},List}>
  Param0
num = 0
start: start
node: start
  Int([Param0,Param1]@Int)
node: [Param0,Param1]@Int
  Param1
  +([Param0,Param1]@Int [Param0,Param1]@Int)
  -([Param0,Param1]@Int [Param0,Param1]@Int)
  fold[List. <nil Unit | cons {{Int,Int},List}>->Int]([Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int [Param0,Param1]@List. <nil Unit | cons {{Int,Int},List}>)
  max([Param0,Param1]@Int [Param0,Param1]@Int)
node: [Param1]@Int
  Param1
  +([Param1]@Int [Param1]@Int)
  -([Param1]@Int [Param1]@Int)
  max([Param1]@Int [Param1]@Int)
node: [Int@0,Int@1,Int@2,Param1]@Int
  Param1
  Int@0
  Int@1
  Int@2
  +([Int@0,Int@1,Int@2,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int)
  -([Int@0,Int@1,Int@2,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int)
  max([Int@0,Int@1,Int@2,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int)
node: [Param0,Param1]@List. <nil Unit | cons {{Int,Int},List}>
  Param0


















  [0] fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@0(),Int@2()),Param0)
  [1] fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@1(),Int@2()),Param0)
  [0] Param1 -> fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@0(),Int@2()),Param0)
  [1] Param1 -> fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@1(),Int@2()),Param0)
  [2] Param0.0
  [3] Param0.1
  [0] fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@0(),Int@2()),Param0)
  [1] fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@1(),Int@2()),Param0)
  [0] Param2
  [] null
  [0] Param3
  [1] Param0 -> fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@0(),Int@2()),Param0)
  [2] Param0 -> fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@1(),Int@2()),Param0)
  [] null
  [0] Param3
  [1] Param0 -> fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@0(),Int@2()),Param0)
  [2] Param0 -> fold[List. <nil Unit | cons {{Int,Int},List}>->Int](Param1,+(Int@1(),Int@2()),Param0)
compress #0: {Int,Int}
pass #0: 
let c0 = p.1 in 
    let c1 = p.2 in 
        {+ h.1 c0, + h.2 c1}
pass #1: 
{lim, lim}
pass #2: 
+ (* -1 lim) h.1
pass #3: 
+ (* -1 lim) h.2

Player = {Int, Int};

Inductive List;

Inductive NList;

Plan = {Int, Int};

Inductive PlanList;

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extend = \p: Player. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {let c0 = p.1 in 
            let c1 = p.2 in 
                {+ h.1 c0, + h.2 c1}, f t}
    end
);

@Input lim = Int;

generate = fix (
    \f: NList -> PlanList. \xs: NList. 
    match xs with
      nnil _ -> pcons {{lim, lim}, pnil Unit}
    | ncons {players, remains} -> 
        let res = (f remains) in 
            fix (
            \g: List -> PlanList. \ys: List. 
            match ys with
              nil _ -> pnil Unit
            | cons {h, t} -> merge (extend h res) (g t)
            end
        ) players
    end
);

max = \a: Int. \b: Int. 
    if (< a b) then b
    else a;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 0
    | pcons {h, t} -> if (<= (+ (* -1 lim) h.1) lim) then max (+ (* -1 lim) h.2) (f t)
        else f t
    end
);

main = \xs: NList. 
    get_best (generate xs);
syn-comb: 1.16013
collect: 8.5368
label: 0.014002
extend-component: 0.04059
execute: 0.731443
syn-align: 9.42631
comb-size: 42
align-size: 23
extract-size: 13
10.6154
Success
