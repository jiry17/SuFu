
Inductive List;

Inductive Graph;

Plan = Int;

Inductive PlanList;

head = \e: Int. \xs: List. 
    match xs with
      nil _ -> e
    | cons {h, t} -> h
    end
;

graph_size = fix (
    \f: Graph -> Int. \g: Graph. 
    match g with
      gnil _ -> 0
    | gcons {h, t} -> + 1 (f t)
    end
);

size = fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + 1 (f t)
    end
);

is_valid_graph = \g: Graph. 
    let si = (graph_size g) in 
        fix (
        \f: Graph -> Bool. \g: Graph. 
        match g with
          gnil _ -> true
        | gcons {h, t} -> if (== si (size h)) then f t
            else false
        end
    ) g;

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

one = 1;

extend = \pos: Int. \w: Int. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> pnil Unit
    | pcons {h, t} -> pcons {+ w h, f t}
    end
);

generate_paths = fix (
    \f: Graph -> PlanList. \graph: Graph. 
    match graph with
      gnil _ -> pcons {0, pnil Unit}
    | gcons {edges, remains} -> 
        let sub_res = (f remains) in 
            fix (
            \g: Int -> List -> PlanList. \pos: Int. \xs: List. 
            match xs with
              nil _ -> pnil Unit
            | cons {h, t} -> merge (extend pos h sub_res) (g (+ 1 pos) t)
            end
        ) 0 edges
    end
);

sum = fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + h (f t)
    end
);

is_val = let check = (fix (
    \f: List -> Int -> Bool. \xs: List. \pre: Int. 
    match xs with
      nil _ -> true
    | cons {h, t} -> and (and (<= h (+ 1 pre)) (>= h (- pre 1))) (f t h)
    end
)) in 
        \xs: List. 
        match xs with
          nil _ -> true
        | cons {h, t} -> check t h
        end
;

min = \a: Int. \b: Int. 
    if (> a b) then b
    else a;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 1000
    | pcons {h, t} -> if (true) then min h (f t)
        else f t
    end
);

main = \graph: Graph. 
    if (is_valid_graph graph) then get_best (generate_paths graph)
    else 0;
