
@Input cost_list = {Int, Int, Int, Int, Int, Int};

Inductive Op;

Inductive OpList;

Plan = OpList;

Inductive PlanList;

Inductive List;

get_cost = \op: Op. 
    match op with
      copy _ -> cost_list.1
    | replace _ -> cost_list.2
    | delete _ -> cost_list.3
    | insert _ -> cost_list.4
    | rotate _ -> cost_list.5
    | kill _ -> cost_list.6
    end
;

extend = \op: Op. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {let c0 = (get_cost op) in 
            + h c0, f t}
    end
);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

size_up_2 = \xs: List. 
    match xs with
      nil _ -> 0
    | cons {_, nil _} -> 1
    | _ -> 2
    end
;

unfold = \xs: List. 
    match xs with
      nil _ -> {0, xs}
    | cons {h, t} -> {h, t}
    end
;

generate = fix (
    \f: List -> List -> PlanList. \xs: List. \ys: List. 
    let xsize = (size_up_2 xs) in 
        let ysize = (size_up_2 ys) in 
            if (and (== xsize 0) (== ysize 0)) then pcons {let c0 = cost_list.1 in 
                c0, pnil Unit}
            else let res0 = (if (and (> xsize 0) (> ysize 0)) then let xinfo = (unfold xs) in 
                let yinfo = (unfold ys) in 
                    let tail_res = (f xinfo.2 yinfo.2) in 
                        let res0 = (extend (replace Unit) tail_res) in 
                            if (== xinfo.1 yinfo.1) then merge res0 (extend (copy Unit) tail_res)
                            else res0
            else pnil Unit) in 
                let res1 = (if (== xsize 0) then pnil Unit
                else let xinfo = (unfold xs) in 
                    extend (delete Unit) (f xinfo.2 ys)) in 
                    let res2 = (if (== ysize 0) then pnil Unit
                    else let yinfo = (unfold ys) in 
                        extend (insert Unit) (f xs yinfo.2)) in 
                        let res3 = (if (or (< xsize 2) (< ysize 2)) then pnil Unit
                        else let xinfo = (unfold xs) in 
                            let xxinfo = (unfold xinfo.2) in 
                                let yinfo = (unfold ys) in 
                                    let yyinfo = (unfold yinfo.2) in 
                                        if (and (== xinfo.1 yyinfo.1) (== xxinfo.1 yinfo.1)) then extend (rotate Unit) (f xxinfo.2 yyinfo.2)
                                        else pnil Unit) in 
                            let res4 = (if (== ysize 0) then pcons {let c0 = cost_list.1 in 
                                let c1 = cost_list.6 in 
                                    + c0 c1, pnil Unit}
                            else pnil Unit) in 
                                merge res4 (merge (merge res0 res1) (merge res2 res3)));

min = \a: Int. \b: Int. 
    if (< a b) then a
    else b;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 1000
    | pcons {h, t} -> min (let c0 = cost_list.1 in 
            - h c0) (f t)
    end
);

main = \xs: List. \ys: List. 
    get_best (generate xs ys);
