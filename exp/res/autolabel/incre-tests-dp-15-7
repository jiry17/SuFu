
Inductive List;

Inductive EdgeList;

Inductive Graph;

Plan = {Bool, Int, Int, Bool};

Inductive PlanList;

graph_size = fix (
    \f: Graph -> Int. \g: Graph. 
    match g with
      gnil _ -> 0
    | gcons {h, t} -> + 1 (f t)
    end
);

length = fix (
    \f: EdgeList -> Int. \xs: EdgeList. 
    match xs with
      enil _ -> 0
    | econs {_, _, t} -> + 1 (f t)
    end
);

size = fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + 1 (f t)
    end
);

is_valid_graph = \g: Graph. 
    let size = (graph_size g) in 
        fix (
        \f: Graph -> Bool. \g: Graph. 
        match g with
          gnil _ -> true
        | gcons {h, t} -> if (== size (length h)) then f t
            else false
        end
    ) g;

@Input cs = List;

@Input len = Int;

one = 1;

take_last = \xs: List. \num: Int. 
    (fix (
    \f: List -> {Int, List}. \xs: List. 
    match xs with
      nil _ -> {0, xs}
    | cons {h, t} -> 
        let res = (f t) in 
            if (< res.1 num) then {+ res.1 1, cons {h, res.2}}
            else res
    end
) xs).2;

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extend = \c: Int. \w: Int. \target: Int. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> pnil Unit
    | pcons {h, t} -> pcons {let c0 = (- target w) in 
            {and (and h.4 (== c0 0)) (== h.3 1), + h.2 w, - h.3 one, and h.4 (== c0 0)}, f t}
    end
);

generate_paths = \full_graph: Graph. 
    let gen = (fix (
    \f: EdgeList -> Graph -> List -> PlanList. \xs: EdgeList. \graph: Graph. \cs: List. 
    match cs with
      nil _ -> pcons {{== len 0, 0, len, true}, pnil Unit}
    | cons {c, ct} -> 
        match {xs, graph} with
          {econs {a, b, t}, gcons {next_edges, remains}} -> merge (extend a b c (f next_edges full_graph ct)) (f t remains cs)
        | _ -> pnil Unit
        end

    end
)) in 
        match full_graph with
          gnil _ -> pnil Unit
        | gcons {h, _} -> gen h full_graph cs
        end
;

is_path_match = fix (
    \f: EdgeList -> List -> Bool. \p: EdgeList. \xs: List. 
    match {p, xs} with
      {enil _, nil _} -> true
    | {econs {_, h1, t1}, cons {h2, t2}} -> and (== h1 h2) (f t1 t2)
    | _ -> false
    end
);

eval = fix (
    \f: EdgeList -> Int. \path: EdgeList. 
    match path with
      econs {_, w, t} -> + w (f t)
    | enil _ -> 0
    end
);

max = \a: Int. \b: Int. 
    if (< a b) then b
    else a;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 0
    | pcons {h, t} -> if (h.1) then max h.2 (f t)
        else f t
    end
);

main = \graph: Graph. 
    if (and (is_valid_graph graph) (== (size cs) len)) then get_best (generate_paths graph)
    else 0;
