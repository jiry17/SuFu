
List :: List. <nil Unit | cons {Int,List}>
nil : Unit -> List'. <nil Unit | cons {Int,List'}>
cons : {Int,List} -> List'. <nil Unit | cons {Int,List'}>
Plan :: List
PlanList :: PlanList. <pnil Unit | pcons {Plan,PlanList}>
pnil : Unit -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
pcons : {Plan,PlanList} ->
        PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
take_back : List -> {Int, List'. <nil Unit | cons {Int,List'}>}
snoc : Int -> List -> List'. <nil Unit | cons {Int,List'}>
rev : List -> List
merge : PlanList -> PlanList -> PlanList
extend : (Plan->Plan) -> PlanList -> PlanList
generate : List -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
max : Int -> Int -> Int
one : Int
get_best : PlanList -> Int
main : List -> Int


Inductive List;

Plan = Compress List;

Inductive PlanList;

take_back = fix (
    \f: List -> {Int, List}. \xs: List. 
    match xs with
      nil _ -> {-1, nil Unit}
    | cons {h, nil _} -> {h, nil Unit}
    | cons {h, t} -> 
        let res = (f t) in 
            {res.1, cons {h, res.2}}
    end
);

snoc = \w: Int. 
    fix (
    \f: List -> List. \xs: List. 
    match xs with
      nil _ -> cons {w, nil Unit}
    | cons {h, t} -> cons {h, f t}
    end
);

rev = fix (
    \f: List -> List -> List. \pre: List. \xs: List. 
    match xs with
      nil _ -> pre
    | cons {h, t} -> f (cons {h, pre}) t
    end
) (nil Unit);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extend = \op: Plan -> Plan. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {op h, f t}
    end
);

generate = fix (
    \f: List -> PlanList. \xs: List. 
    match xs with
      nil _ -> pcons {let tmp1 = (nil Unit) in 
            align (label tmp1 ) , pnil Unit}
    | cons {h, nil _} -> pcons {align (label xs ) , pcons {let tmp2 = (nil Unit) in 
            align (label tmp2 ) , pnil Unit}}
    | cons {h, t} -> 
        let last = (take_back t) in 
            let res = (merge (f t) (f (cons {h, last.2}))) in 
                if (== h last.1) then merge (extend (\xs: Plan. 
                let tmp3 = (snoc last.1) in 
                    align (label (cons {h, tmp3 (unlabel xs )}) ) ) (f last.2)) res
                else res
    end
);

max = \a: Int. \b: Int. 
    if (< a b) then b
    else a;

one = 1;

get_best = let eval = (fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + 1 (f t)
    end
)) in 
        fix (
        \f: PlanList -> Int. \xs: PlanList. 
        match xs with
          pnil _ -> 0
        | pcons {h, t} -> max (align (eval (unlabel h )) ) (f t)
        end
    );

main = \xs: List. 
    get_best (generate xs);
align term #0: compress[0] List. <nil Unit | cons {Int,List}>
align@0 create@0 tmp1
  tmp1: List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
align term #1: compress[0] List. <nil Unit | cons {Int,List}>
align@1 create@0 xs
  h: Int
  xs: List. <nil Unit | cons {Int,List}>
align term #2: compress[0] List. <nil Unit | cons {Int,List}>
align@2 create@0 tmp2
  tmp2: List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
  h: Int
align term #3: compress[0] List. <nil Unit | cons {Int,List}>
align@3 create@0 cons ({h,tmp3 (unlabel xs)})
  res: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {Int,List}>,PlanList}>
  h: Int
  last: {Int,List. <nil Unit | cons {Int,List}>}
  xs: compress[0] List. <nil Unit | cons {Int,List}>
  t: List. <nil Unit | cons {Int,List}>
align term #4: Int
align@4 eval (unlabel h)
  h: compress[0] List. <nil Unit | cons {Int,List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {Int,List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {Int,List}>,PlanList}>
Components for compress:
  one [] -> Int 10
  max [Int,Int] -> Int 9
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0

Components for align:
  one [] -> Int 10
  max [Int,Int] -> Int 9
  snoc [Int,List. <nil Unit | cons {Int,List}>] -> List. <nil Unit | cons {Int,List}> 4
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  take_back [List. <nil Unit | cons {Int,List}>] -> (Int * List. <nil Unit | cons {Int,List}>) 3
  rev [List. <nil Unit | cons {Int,List}>] -> List. <nil Unit | cons {Int,List}> 5
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0

Components for comb:
  one [] -> Int 10
  max [Int,Int] -> Int 9
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0

align term #0: compress[0] List. <nil Unit | cons {Int,List}>
align@0 create@0 tmp1
  tmp1: List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
align term #1: compress[0] List. <nil Unit | cons {Int,List}>
align@1 create@0 xs
  h: Int
  xs: List. <nil Unit | cons {Int,List}>
align term #2: compress[0] List. <nil Unit | cons {Int,List}>
align@2 create@0 tmp2
  tmp2: List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
  h: Int
align term #3: compress[0] List. <nil Unit | cons {Int,List}>
align@3 create@0 cons ({h,tmp3 (unlabel xs)})
  res: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {Int,List}>,PlanList}>
  h: Int
  last: {Int,List. <nil Unit | cons {Int,List}>}
  xs: compress[0] List. <nil Unit | cons {Int,List}>
  t: List. <nil Unit | cons {Int,List}>
align term #4: Int
align@4 eval (unlabel h)
  h: compress[0] List. <nil Unit | cons {Int,List}>
  t: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {Int,List}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] List. <nil Unit | cons {Int,List}>,PlanList}>
num = 0
start: start
node: start
  Int([Param0,Param1]@Int)
node: [Param0,Param1]@Int
  +([Param0,Param1]@Int [Param0,Param1]@Int)
  -([Param0,Param1]@Int [Param0,Param1]@Int)
  0
  1
num = 1
start: start
node: start
  Int([Param0,Param1]@Int)
node: [Param0,Param1]@Int
  Param0
  +([Param0,Param1]@Int [Param0,Param1]@Int)
  -([Param0,Param1]@Int [Param0,Param1]@Int)
  0
  1
num = 2
start: start
node: start
  Int([Param0,Param1,Param2]@Int)
node: [Param0,Param1,Param2]@Int
  Param2
  +([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  -([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  0
  1
num = 3
start: start
node: start
  Int([Param0,Param1,Param2,Param3,Param4]@Int)
  Compress[0] List. <nil Unit | cons {Int,List}>([Param0,Param1,Param2,Param3,Param4]@Compress[0] List. <nil Unit | cons {Int,List}>)
node: [Param0,Param1,Param2,Param3,Param4]@Int
  Param1
  +([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
  -([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
  0
  1
  access0([Param0,Param1,Param2,Param3,Param4]@(Int * List. <nil Unit | cons {Int,List}>))
node: [Param0,Param1,Param2,Param3,Param4]@(Int * List. <nil Unit | cons {Int,List}>)
  Param2
  prod([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@List. <nil Unit | cons {Int,List}>)
node: [Param0,Param1,Param2,Param3,Param4]@Compress[0] List. <nil Unit | cons {Int,List}>
  Param3
node: [Param0,Param1,Param2,Param3,Param4]@List. <nil Unit | cons {Int,List}>
  Param4
  access1([Param0,Param1,Param2,Param3,Param4]@(Int * List. <nil Unit | cons {Int,List}>))
  cons([Param0,Param1,Param2,Param3,Param4]@(Int * List. <nil Unit | cons {Int,List}>))
num = 4
start: start
node: start
  Compress[0] List. <nil Unit | cons {Int,List}>([Param0,Param1,Param2]@Compress[0] List. <nil Unit | cons {Int,List}>)
  Int([Param0,Param1,Param2]@Int)
node: [Param0,Param1,Param2]@Int
  +([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  -([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  0
  1
  one
  max([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
node: [Param0,Param1,Param2]@Compress[0] List. <nil Unit | cons {Int,List}>
  Param0
num = 0
start: start
node: start
  Int([Param0]@Int)
node: [Int@0,Int@1]@Int
  Int@0
  Int@1
  +([Int@0,Int@1]@Int [Int@0,Int@1]@Int)
  -([Int@0,Int@1]@Int [Int@0,Int@1]@Int)
  one
  max([Int@0,Int@1]@Int [Int@0,Int@1]@Int)
node: [Param0]@Int
  +([Param0]@Int [Param0]@Int)
  -([Param0]@Int [Param0]@Int)
  access0([Param0]@(Int * List. <nil Unit | cons {Int,List}>))
  fold[List. <nil Unit | cons {Int,List}>->Int]([]@Int [Int@0,Int@1]@Int [Param0]@List. <nil Unit | cons {Int,List}>)
  one
  max([Param0]@Int [Param0]@Int)
node: []@Int
  +([]@Int []@Int)
  -([]@Int []@Int)
  one
  max([]@Int []@Int)
node: [Param0]@(Int * List. <nil Unit | cons {Int,List}>)
  prod([Param0]@Int [Param0]@List. <nil Unit | cons {Int,List}>)
  take_back([Param0]@List. <nil Unit | cons {Int,List}>)
node: [Param0]@List. <nil Unit | cons {Int,List}>
  Param0
  access1([Param0]@(Int * List. <nil Unit | cons {Int,List}>))
  snoc([Param0]@Int [Param0]@List. <nil Unit | cons {Int,List}>)
  rev([Param0]@List. <nil Unit | cons {Int,List}>)
  cons([Param0]@(Int * List. <nil Unit | cons {Int,List}>))















  [] fold[List. <nil Unit | cons {Int,List}>->Int](one(),+(Int@1(),one()),Param0)
  [] fold[List. <nil Unit | cons {Int,List}>->Int](one(),+(Int@1(),one()),Param0)
  [] fold[List. <nil Unit | cons {Int,List}>->Int](one(),+(Int@1(),one()),Param0)
  [] fold[List. <nil Unit | cons {Int,List}>->Int](one(),+(Int@1(),one()),Param0)
  [0] Param3 -> fold[List. <nil Unit | cons {Int,List}>->Int](one(),+(Int@1(),one()),Param0)
  [] null
  [0] Param0 -> fold[List. <nil Unit | cons {Int,List}>->Int](one(),+(Int@1(),one()),Param0)
compress #0: Int
pass #0: 
1
pass #1: 
+ 1 1
pass #2: 
1
pass #3: 
+ xs (+ 1 1)
pass #4: 
- h 1

Inductive List;

Plan = Int;

Inductive PlanList;

take_back = fix (
    \f: List -> {Int, List}. \xs: List. 
    match xs with
      nil _ -> {-1, nil Unit}
    | cons {h, nil _} -> {h, nil Unit}
    | cons {h, t} -> 
        let res = (f t) in 
            {res.1, cons {h, res.2}}
    end
);

snoc = \w: Int. 
    fix (
    \f: List -> List. \xs: List. 
    match xs with
      nil _ -> cons {w, nil Unit}
    | cons {h, t} -> cons {h, f t}
    end
);

rev = fix (
    \f: List -> List -> List. \pre: List. \xs: List. 
    match xs with
      nil _ -> pre
    | cons {h, t} -> f (cons {h, pre}) t
    end
) (nil Unit);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extend = \op: Plan -> Plan. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {op h, f t}
    end
);

generate = fix (
    \f: List -> PlanList. \xs: List. 
    match xs with
      nil _ -> pcons {1, pnil Unit}
    | cons {h, nil _} -> pcons {+ 1 1, pcons {1, pnil Unit}}
    | cons {h, t} -> 
        let last = (take_back t) in 
            let res = (merge (f t) (f (cons {h, last.2}))) in 
                if (== h last.1) then merge (extend (\xs: Plan. 
                + xs (+ 1 1)) (f last.2)) res
                else res
    end
);

max = \a: Int. \b: Int. 
    if (< a b) then b
    else a;

one = 1;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 0
    | pcons {h, t} -> max (- h 1) (f t)
    end
);

main = \xs: List. 
    get_best (generate xs);
syn-comb: 0.93236
collect: 64.7034
label: 0.018075
extend-component: 0.006471
execute: 0.078898
syn-align: 64.8769
comb-size: 21
align-size: 11
extract-size: 2
65.8365
Success
