
cost_list : {Int, Int, Int, Int, Int, Int}
Op :: Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
copy : Unit ->
       Op'. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
replace : Unit ->
          Op'. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
delete : Unit ->
         Op'. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
insert : Unit ->
         Op'. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
rotate : Unit ->
         Op'. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
kill : Unit ->
       Op'. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
OpList :: OpList. <onil Unit | ocons {Op,OpList}>
onil : Unit -> OpList'. <onil Unit | ocons {Op,OpList'}>
ocons : {Op,OpList} -> OpList'. <onil Unit | ocons {Op,OpList'}>
Plan :: OpList
PlanList :: PlanList. <pnil Unit | pcons {Plan,PlanList}>
pnil : Unit -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
pcons : {Plan,PlanList} ->
        PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
List :: List. <nil Unit | cons {Int,List}>
nil : Unit -> List'. <nil Unit | cons {Int,List'}>
cons : {Int,List} -> List'. <nil Unit | cons {Int,List'}>
get_cost : Op -> Int
extend : Op -> PlanList -> PlanList
merge : PlanList -> PlanList -> PlanList
size_up_2 : List -> Int
unfold : List -> {Int, List}
generate : List ->
           List -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
min : Int -> Int -> Int
get_best : PlanList -> Int
main : List -> List -> Int


@Input cost_list = {Int, Int, Int, Int, Int, Int};

Inductive Op;

Inductive OpList;

Plan = OpList;

Inductive PlanList;

Inductive List;

get_cost = \op: Op. 
    match op with
      copy _ -> cost_list.1
    | replace _ -> cost_list.2
    | delete _ -> cost_list.3
    | insert _ -> cost_list.4
    | rotate _ -> cost_list.5
    | kill _ -> cost_list.6
    end
;

extend = \op: Op. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {align (label (ocons {op, unlabel h }) ) , f t}
    end
);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

size_up_2 = \xs: List. 
    match xs with
      nil _ -> 0
    | cons {_, nil _} -> 1
    | _ -> 2
    end
;

unfold = \xs: List. 
    match xs with
      nil _ -> {0, xs}
    | cons {h, t} -> {h, t}
    end
;

generate = fix (
    \f: List -> List -> PlanList. \xs: List. \ys: List. 
    let xsize = (size_up_2 xs) in 
        let ysize = (size_up_2 ys) in 
            if (and (== xsize 0) (== ysize 0)) then pcons {let tmp1 = (onil Unit) in 
                align (label tmp1 ) , pnil Unit}
            else let res0 = (if (and (> xsize 0) (> ysize 0)) then let xinfo = (unfold xs) in 
                let yinfo = (unfold ys) in 
                    let tail_res = (f xinfo.2 yinfo.2) in 
                        let res0 = (extend (replace Unit) tail_res) in 
                            if (== xinfo.1 yinfo.1) then merge res0 (extend (copy Unit) tail_res)
                            else res0
            else pnil Unit) in 
                let res1 = (if (== xsize 0) then pnil Unit
                else let xinfo = (unfold xs) in 
                    extend (delete Unit) (f xinfo.2 ys)) in 
                    let res2 = (if (== ysize 0) then pnil Unit
                    else let yinfo = (unfold ys) in 
                        extend (insert Unit) (f xs yinfo.2)) in 
                        let res3 = (if (or (< xsize 2) (< ysize 2)) then pnil Unit
                        else let xinfo = (unfold xs) in 
                            let xxinfo = (unfold xinfo.2) in 
                                let yinfo = (unfold ys) in 
                                    let yyinfo = (unfold yinfo.2) in 
                                        if (and (== xinfo.1 yyinfo.1) (== xxinfo.1 yinfo.1)) then extend (rotate Unit) (f xxinfo.2 yyinfo.2)
                                        else pnil Unit) in 
                            let res4 = (if (== ysize 0) then let kill_plan = (ocons {kill Unit, onil Unit}) in 
                                pcons {align (label kill_plan ) , pnil Unit}
                            else pnil Unit) in 
                                merge res4 (merge (merge res0 res1) (merge res2 res3)));

min = \a: Int. \b: Int. 
    if (< a b) then a
    else b;

get_best = let eval = (fix (
    \f: Plan -> Int. \xs: Plan. 
    match xs with
      onil _ -> 0
    | ocons {h, t} -> + (get_cost h) (f t)
    end
)) in 
        fix (
        \f: PlanList -> Int. \xs: PlanList. 
        match xs with
          pnil _ -> 1000
        | pcons {h, t} -> min (align (eval (unlabel h )) ) (f t)
        end
    );

main = \xs: List. \ys: List. 
    get_best (generate xs ys);
align term #0: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
align@0 create@0 ocons ({op,unlabel h})
  h: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  t: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  op: Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
align term #1: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
align@1 create@0 tmp1
  ys: List. <nil Unit | cons {Int,List}>
  ysize: Int
  xs: List. <nil Unit | cons {Int,List}>
  tmp1: OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  xsize: Int
align term #2: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
align@2 create@0 kill_plan
  xs: List. <nil Unit | cons {Int,List}>
  ys: List. <nil Unit | cons {Int,List}>
  xsize: Int
  res1: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  kill_plan: OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  ysize: Int
  res0: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  res2: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  res3: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
align term #3: Int
align@3 eval (unlabel h)
  h: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  t: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
Components for compress:
  min [Int,Int] -> Int 12
  size_up_2 [List. <nil Unit | cons {Int,List}>] -> Int 9
  get_cost [Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>] -> Int 6
  insert [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 5
  rotate [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  delete [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 5
  copy [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  replace [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  ocons [(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> * OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>)] -> OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}> 2
  kill [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  unfold [List. <nil Unit | cons {Int,List}>] -> (Int * List. <nil Unit | cons {Int,List}>) 10
  onil [Bot] -> OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}> 2

Components for align:
  min [Int,Int] -> Int 12
  size_up_2 [List. <nil Unit | cons {Int,List}>] -> Int 9
  get_cost [Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>] -> Int 6
  insert [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 5
  rotate [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  delete [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 5
  copy [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  replace [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  ocons [(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> * OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>)] -> OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}> 2
  kill [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  unfold [List. <nil Unit | cons {Int,List}>] -> (Int * List. <nil Unit | cons {Int,List}>) 10
  onil [Bot] -> OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}> 2

Components for comb:
  min [Int,Int] -> Int 12
  size_up_2 [List. <nil Unit | cons {Int,List}>] -> Int 9
  get_cost [Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>] -> Int 6
  insert [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 5
  rotate [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  delete [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 5
  copy [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  replace [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  ocons [(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> * OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>)] -> OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}> 2
  kill [Bot] -> Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit> 1
  unfold [List. <nil Unit | cons {Int,List}>] -> (Int * List. <nil Unit | cons {Int,List}>) 10
  onil [Bot] -> OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}> 2

align term #0: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
align@0 create@0 ocons ({op,unlabel h})
  h: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  t: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  op: Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
align term #1: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
align@1 create@0 tmp1
  ys: List. <nil Unit | cons {Int,List}>
  ysize: Int
  xs: List. <nil Unit | cons {Int,List}>
  tmp1: OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  xsize: Int
align term #2: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
align@2 create@0 kill_plan
  xs: List. <nil Unit | cons {Int,List}>
  ys: List. <nil Unit | cons {Int,List}>
  xsize: Int
  res1: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  kill_plan: OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  ysize: Int
  res0: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  res2: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  res3: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
align term #3: Int
align@3 eval (unlabel h)
  h: compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  t: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>,PlanList}>
num = 0
start: start
node: start
  Compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>([Param0,Param1,Param2,Param3,Param4]@Compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>)
  Int([Param0,Param1,Param2,Param3,Param4]@Int)
node: [Param0,Param1,Param2,Param3,Param4]@Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
  Param3
node: [Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int)
  Param4
  prod([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
node: [Param0,Param1,Param2,Param3,Param4]@Int
  +([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
  -([Param0,Param1,Param2,Param3,Param4]@Int [Param0,Param1,Param2,Param3,Param4]@Int)
  0
  1
  access0([Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int))
  access1([Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int))
  access2([Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int))
  access3([Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int))
  access4([Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int))
  access5([Param0,Param1,Param2,Param3,Param4]@(Int * Int * Int * Int * Int * Int))
  get_cost([Param0,Param1,Param2,Param3,Param4]@Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>)
node: [Param0,Param1,Param2,Param3,Param4]@Compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  Param0
num = 1
start: start
node: start
  Int([Param0,Param1,Param2,Param3,Param4,Param5]@Int)
node: [Param0,Param1,Param2,Param3,Param4,Param5]@Int
  Param1
  Param4
  +([Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int)
  -([Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int)
  0
  1
  access0([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int))
  access1([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int))
  access2([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int))
  access3([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int))
  access4([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int))
  access5([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int))
  access0([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * List. <nil Unit | cons {Int,List}>))
  size_up_2([Param0,Param1,Param2,Param3,Param4,Param5]@List. <nil Unit | cons {Int,List}>)
node: [Param0,Param1,Param2,Param3,Param4,Param5]@(Int * Int * Int * Int * Int * Int)
  Param5
  prod([Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int)
node: [Param0,Param1,Param2,Param3,Param4,Param5]@(Int * List. <nil Unit | cons {Int,List}>)
  prod([Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@List. <nil Unit | cons {Int,List}>)
  unfold([Param0,Param1,Param2,Param3,Param4,Param5]@List. <nil Unit | cons {Int,List}>)
node: [Param0,Param1,Param2,Param3,Param4,Param5]@List. <nil Unit | cons {Int,List}>
  Param0
  Param2
  access1([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * List. <nil Unit | cons {Int,List}>))
  cons([Param0,Param1,Param2,Param3,Param4,Param5]@(Int * List. <nil Unit | cons {Int,List}>))
num = 2
start: start
node: start
  Int([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int)
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int
  Param2
  Param5
  +([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int)
  -([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int)
  0
  1
  access0([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int))
  access1([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int))
  access2([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int))
  access3([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int))
  access4([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int))
  access5([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int))
  access0([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * List. <nil Unit | cons {Int,List}>))
  size_up_2([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@List. <nil Unit | cons {Int,List}>)
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * Int * Int * Int * Int * Int)
  Param9
  prod([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int)
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * List. <nil Unit | cons {Int,List}>)
  prod([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@List. <nil Unit | cons {Int,List}>)
  unfold([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@List. <nil Unit | cons {Int,List}>)
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@List. <nil Unit | cons {Int,List}>
  Param0
  Param1
  access1([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * List. <nil Unit | cons {Int,List}>))
  cons([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7,Param8,Param9]@(Int * List. <nil Unit | cons {Int,List}>))
num = 3
start: start
node: start
  Compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>([Param0,Param1,Param2,Param3]@Compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>)
  Int([Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int)
  Param3
  prod([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Int
  +([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  -([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  0
  1
  access0([Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int))
  access1([Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int))
  access2([Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int))
  access3([Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int))
  access4([Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int))
  access5([Param0,Param1,Param2,Param3]@(Int * Int * Int * Int * Int * Int))
  min([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Compress[0] OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  Param0
num = 0
start: start
node: start
  Int([Param0,Param1]@Int)
node: [Param0,Param1]@(Int * Int * Int * Int * Int * Int)
  Param1
  prod([Param0,Param1]@Int [Param0,Param1]@Int [Param0,Param1]@Int [Param0,Param1]@Int [Param0,Param1]@Int [Param0,Param1]@Int)
node: [Param1]@(Int * Int * Int * Int * Int * Int)
  Param1
  prod([Param1]@Int [Param1]@Int [Param1]@Int [Param1]@Int [Param1]@Int [Param1]@Int)
node: [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int)
  Param1
  prod([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int)
node: [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>
  Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0
node: [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int
  Int@0
  +([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int)
  -([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int)
  access0([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access1([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access2([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access3([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access4([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access5([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@(Int * Int * Int * Int * Int * Int))
  fold[Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>->Int]([Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>)
  min([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int)
  get_cost([Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>)
node: [Int@0,Param1]@(Int * Int * Int * Int * Int * Int)
  Param1
  prod([Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int [Int@0,Param1]@Int)
node: [Int@0,Param1]@Int
  Int@0
  +([Int@0,Param1]@Int [Int@0,Param1]@Int)
  -([Int@0,Param1]@Int [Int@0,Param1]@Int)
  access0([Int@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access1([Int@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access2([Int@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access3([Int@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access4([Int@0,Param1]@(Int * Int * Int * Int * Int * Int))
  access5([Int@0,Param1]@(Int * Int * Int * Int * Int * Int))
  min([Int@0,Param1]@Int [Int@0,Param1]@Int)
node: [Param0,Param1]@Int
  +([Param0,Param1]@Int [Param0,Param1]@Int)
  -([Param0,Param1]@Int [Param0,Param1]@Int)
  access0([Param0,Param1]@(Int * Int * Int * Int * Int * Int))
  access1([Param0,Param1]@(Int * Int * Int * Int * Int * Int))
  access2([Param0,Param1]@(Int * Int * Int * Int * Int * Int))
  access3([Param0,Param1]@(Int * Int * Int * Int * Int * Int))
  access4([Param0,Param1]@(Int * Int * Int * Int * Int * Int))
  access5([Param0,Param1]@(Int * Int * Int * Int * Int * Int))
  fold[OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>->Int]([Param1]@Int [Int@0,Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0,Param1]@Int [Param0,Param1]@OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>)
  min([Param0,Param1]@Int [Param0,Param1]@Int)
node: [Param1]@Int
  +([Param1]@Int [Param1]@Int)
  -([Param1]@Int [Param1]@Int)
  access0([Param1]@(Int * Int * Int * Int * Int * Int))
  access1([Param1]@(Int * Int * Int * Int * Int * Int))
  access2([Param1]@(Int * Int * Int * Int * Int * Int))
  access3([Param1]@(Int * Int * Int * Int * Int * Int))
  access4([Param1]@(Int * Int * Int * Int * Int * Int))
  access5([Param1]@(Int * Int * Int * Int * Int * Int))
  min([Param1]@Int [Param1]@Int)
node: [Param0,Param1]@OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>
  Param0












  [] fold[OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>->Int](Param1.0,+(Int@0(),get_cost(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0())),Param0)
  [0] Param0 -> fold[OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>->Int](Param1.0,+(Int@0(),get_cost(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0())),Param0)
  [1] get_cost(Param3)
  [] fold[OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>->Int](Param1.0,+(Int@0(),get_cost(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0())),Param0)
  [0] Param5.0
  [] fold[OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>->Int](Param1.0,+(Int@0(),get_cost(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0())),Param0)
  [0] Param9.0
  [1] Param9.5
  [] null
  [0] Param3.0
  [1] Param0 -> fold[OpList. <onil Unit | ocons {Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>,OpList}>->Int](Param1.0,+(Int@0(),get_cost(Op. <copy Unit | replace Unit | delete Unit | insert Unit | rotate Unit | kill Unit>@0())),Param0)
compress #0: Int
pass #0: 
let c0 = (get_cost op) in 
    + h c0
pass #1: 
let c0 = cost_list.1 in 
    c0
pass #2: 
let c0 = cost_list.1 in 
    let c1 = cost_list.6 in 
        + c0 c1
pass #3: 
let c0 = cost_list.1 in 
    - h c0

@Input cost_list = {Int, Int, Int, Int, Int, Int};

Inductive Op;

Inductive OpList;

Plan = OpList;

Inductive PlanList;

Inductive List;

get_cost = \op: Op. 
    match op with
      copy _ -> cost_list.1
    | replace _ -> cost_list.2
    | delete _ -> cost_list.3
    | insert _ -> cost_list.4
    | rotate _ -> cost_list.5
    | kill _ -> cost_list.6
    end
;

extend = \op: Op. 
    fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> pcons {let c0 = (get_cost op) in 
            + h c0, f t}
    end
);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

size_up_2 = \xs: List. 
    match xs with
      nil _ -> 0
    | cons {_, nil _} -> 1
    | _ -> 2
    end
;

unfold = \xs: List. 
    match xs with
      nil _ -> {0, xs}
    | cons {h, t} -> {h, t}
    end
;

generate = fix (
    \f: List -> List -> PlanList. \xs: List. \ys: List. 
    let xsize = (size_up_2 xs) in 
        let ysize = (size_up_2 ys) in 
            if (and (== xsize 0) (== ysize 0)) then pcons {let c0 = cost_list.1 in 
                c0, pnil Unit}
            else let res0 = (if (and (> xsize 0) (> ysize 0)) then let xinfo = (unfold xs) in 
                let yinfo = (unfold ys) in 
                    let tail_res = (f xinfo.2 yinfo.2) in 
                        let res0 = (extend (replace Unit) tail_res) in 
                            if (== xinfo.1 yinfo.1) then merge res0 (extend (copy Unit) tail_res)
                            else res0
            else pnil Unit) in 
                let res1 = (if (== xsize 0) then pnil Unit
                else let xinfo = (unfold xs) in 
                    extend (delete Unit) (f xinfo.2 ys)) in 
                    let res2 = (if (== ysize 0) then pnil Unit
                    else let yinfo = (unfold ys) in 
                        extend (insert Unit) (f xs yinfo.2)) in 
                        let res3 = (if (or (< xsize 2) (< ysize 2)) then pnil Unit
                        else let xinfo = (unfold xs) in 
                            let xxinfo = (unfold xinfo.2) in 
                                let yinfo = (unfold ys) in 
                                    let yyinfo = (unfold yinfo.2) in 
                                        if (and (== xinfo.1 yyinfo.1) (== xxinfo.1 yinfo.1)) then extend (rotate Unit) (f xxinfo.2 yyinfo.2)
                                        else pnil Unit) in 
                            let res4 = (if (== ysize 0) then pcons {let c0 = cost_list.1 in 
                                let c1 = cost_list.6 in 
                                    + c0 c1, pnil Unit}
                            else pnil Unit) in 
                                merge res4 (merge (merge res0 res1) (merge res2 res3)));

min = \a: Int. \b: Int. 
    if (< a b) then a
    else b;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 1000
    | pcons {h, t} -> min (let c0 = cost_list.1 in 
            - h c0) (f t)
    end
);

main = \xs: List. \ys: List. 
    get_best (generate xs ys);
syn-comb: 0.731444
collect: 62.537
label: 0.034594
extend-component: 0.177379
execute: 0.879286
syn-align: 64.3382
comb-size: 32
align-size: 14
extract-size: 16
65.1293
Success
