
List :: List. <nil Unit | cons {Int,List}>
nil : Unit -> List'. <nil Unit | cons {Int,List'}>
cons : {Int,List} -> List'. <nil Unit | cons {Int,List'}>
LineList :: LineList. <lnil Unit | lcons {List,LineList}>
lnil : Unit -> LineList'. <lnil Unit | lcons {List,LineList'}>
lcons : {List,LineList} ->
        LineList'. <lnil Unit | lcons {List,LineList'}>
Plan :: LineList
PlanList :: PlanList. <pnil Unit | pcons {Plan,PlanList}>
pnil : Unit -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
pcons : {Plan,PlanList} ->
        PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
lim : Int
size : List -> Int
sum : List -> Int
line_cost : List -> Int
merge : PlanList -> PlanList -> PlanList
head_size : Plan -> Int
extend : Int ->
         PlanList ->
         PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
generate : List -> PlanList'. <pnil Unit | pcons {Plan,PlanList'}>
eval : Plan -> Int
min : Int -> Int -> Int
get_best : PlanList -> Int
main : List -> Int


Inductive List;

Inductive LineList;

Plan = LineList;

Inductive PlanList;

@Input lim = Int;

size = fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + 1 (f t)
    end
);

sum = fix (
    \f: List -> Int. \xs: List. 
    match xs with
      nil _ -> 0
    | cons {h, t} -> + h (f t)
    end
);

line_cost = let triple = (\x: Int. 
    * (* x x) x) in 
        \xs: List. 
        let len = (- (+ (sum xs) (size xs)) 1) in 
            triple (- lim len);

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

head_size = \xs: Plan. 
    match xs with
      lnil _ -> + lim 1
    | lcons {h, t} -> + (sum h) (size h)
    end
;

extend = \x: Int. \xs: PlanList. 
    if (> x lim) then pnil Unit
    else fix (
    \f: PlanList -> PlanList. \xs: PlanList. 
    match xs with
      pnil _ -> xs
    | pcons {h, t} -> 
        let res = (f t) in 
            let hcost = (align (head_size (unlabel h )) ) in 
                let new_plan = (let tmp1 = (cons {x, nil Unit}) in 
                    align (label (lcons {tmp1, unlabel h }) ) ) in 
                    if (<= (+ x hcost) lim) then let insert_plan = (align (match unlabel h  with
                      lcons {h, t} -> label (lcons {cons {x, h}, t}) 
                    end
) ) in 
                        pcons {insert_plan, pcons {new_plan, res}}
                    else pcons {new_plan, res}
    end
) xs;

generate = fix (
    \f: List -> PlanList. \xs: List. 
    match xs with
      nil _ -> pcons {let tmp2 = (lnil Unit) in 
            align (label tmp2 ) , pnil Unit}
    | cons {h, t} -> extend h (f t)
    end
);

eval = fix (
    \f: Plan -> Int. \xs: Plan. 
    match xs with
      lnil _ -> 0
    | lcons {h, lnil _} -> 0
    | lcons {h, t} -> + (line_cost h) (f t)
    end
);

min = \a: Int. \b: Int. 
    if (< a b) then a
    else b;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 1000
    | pcons {h, t} -> min (align (eval (unlabel h )) ) (f t)
    end
);

main = \xs: List. 
    get_best (generate xs);
align term #0: Int
align@0 head_size (unlabel h)
  res: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  x: Int
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
align term #1: compress[0] LineList. <lnil Unit | lcons {List,LineList}>
align@1 create@0 lcons ({tmp1,unlabel h})
  hcost: Int
  res: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  x: Int
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  tmp1: List. <nil Unit | cons {Int,List}>
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
align term #2: compress[0] LineList. <lnil Unit | lcons {List,LineList}>
align@2 match unlabel h with lcons {h,t} -> create@0 lcons ({cons ({x,h}),t})
  hcost: Int
  res: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  new_plan: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  x: Int
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
align term #3: compress[0] LineList. <lnil Unit | lcons {List,LineList}>
align@3 create@0 tmp2
  xs: List. <nil Unit | cons {Int,List}>
  tmp2: LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
align term #4: Int
align@4 eval (unlabel h)
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
Components for compress:
  min [Int,Int] -> Int 13
  lcons [(List. <nil Unit | cons {Int,List}> * LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)] -> LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}> 1
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  lnil [Bot] -> LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}> 1

Components for align:
  min [Int,Int] -> Int 13
  eval [LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>] -> Int 12
  lcons [(List. <nil Unit | cons {Int,List}> * LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)] -> LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}> 1
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  sum [List. <nil Unit | cons {Int,List}>] -> Int 6
  size [List. <nil Unit | cons {Int,List}>] -> Int 5
  line_cost [List. <nil Unit | cons {Int,List}>] -> Int 7
  lnil [Bot] -> LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}> 1
  head_size [LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>] -> Int 9

Components for comb:
  min [Int,Int] -> Int 13
  lcons [(List. <nil Unit | cons {Int,List}> * LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)] -> LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}> 1
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  lnil [Bot] -> LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}> 1

align term #0: Int
align@0 head_size (unlabel h)
  res: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  x: Int
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  (0) {h: compress[0] Lnil Unit,res: Pnil Unit,x: 1,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit),t: Pnil Unit} @ {lim: 3} -> 4
  (0) {h: compress[0] Lnil Unit,res: Pnil Unit,x: 3,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit),t: Pnil Unit} @ {lim: 3} -> 4
  (0) {h: compress[0] Lnil Unit,res: Pnil Unit,x: 4,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit),t: Pnil Unit} @ {lim: 4} -> 5
  (0) {h: compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit),res: Pnil Unit,x: 2,xs: Pcons (compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit)) (Pnil Unit),t: Pnil Unit} @ {lim: 4} -> 5
  (0) {h: compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)),res: Pnil Unit,x: 0,xs: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))) (Pnil Unit),t: Pnil Unit} @ {lim: 4} -> 3
  (0) {h: compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))),res: Pnil Unit,x: 1,xs: Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit),t: Pnil Unit} @ {lim: 4} -> 1
  (0) {h: compress[0] Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)),res: Pcons (compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit)),x: 1,xs: Pcons (compress[0] Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))) (Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit)),t: Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit)} @ {lim: 4} -> 4
  (0) {h: compress[0] Lnil Unit,res: Pnil Unit,x: 2,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit),t: Pnil Unit} @ {lim: 3} -> 4
  (0) {h: compress[0] Lnil Unit,res: Pnil Unit,x: 4,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit),t: Pnil Unit} @ {lim: 5} -> 6
  (0) {h: compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit),res: Pnil Unit,x: 3,xs: Pcons (compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit)) (Pnil Unit),t: Pnil Unit} @ {lim: 5} -> 5
align term #1: compress[0] LineList. <lnil Unit | lcons {List,LineList}>
align@1 create@0 lcons ({tmp1,unlabel h})
  hcost: Int
  res: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  x: Int
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  tmp1: List. <nil Unit | cons {Int,List}>
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  (1) {res: Pnil Unit,h: compress[0] Lnil Unit,hcost: 4,x: 1,tmp1: Cons (1) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit)} @ {lim: 3} -> compress[0] Lcons (Cons (1) (Nil Unit)) (Lnil Unit)
  (1) {res: Pnil Unit,h: compress[0] Lnil Unit,hcost: 4,x: 3,tmp1: Cons (3) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit)} @ {lim: 3} -> compress[0] Lcons (Cons (3) (Nil Unit)) (Lnil Unit)
  (1) {res: Pnil Unit,h: compress[0] Lnil Unit,hcost: 5,x: 4,tmp1: Cons (4) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit)} @ {lim: 4} -> compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit)
  (1) {res: Pnil Unit,h: compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit),hcost: 5,x: 2,tmp1: Cons (2) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit)) (Pnil Unit)} @ {lim: 4} -> compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))
  (1) {res: Pnil Unit,h: compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)),hcost: 3,x: 0,tmp1: Cons (0) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))) (Pnil Unit)} @ {lim: 4} -> compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))
  (1) {res: Pnil Unit,h: compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))),hcost: 1,x: 1,tmp1: Cons (1) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit)} @ {lim: 4} -> compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))
  (1) {res: Pcons (compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit)),h: compress[0] Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)),hcost: 4,x: 1,tmp1: Cons (1) (Nil Unit),t: Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit),xs: Pcons (compress[0] Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))) (Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit))} @ {lim: 4} -> compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))
  (1) {res: Pnil Unit,h: compress[0] Lnil Unit,hcost: 4,x: 2,tmp1: Cons (2) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit)} @ {lim: 3} -> compress[0] Lcons (Cons (2) (Nil Unit)) (Lnil Unit)
  (1) {res: Pnil Unit,h: compress[0] Lnil Unit,hcost: 6,x: 4,tmp1: Cons (4) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit)} @ {lim: 5} -> compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit)
  (1) {res: Pnil Unit,h: compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit),hcost: 5,x: 3,tmp1: Cons (3) (Nil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (4) (Nil Unit)) (Lnil Unit)) (Pnil Unit)} @ {lim: 5} -> compress[0] Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))
align term #2: compress[0] LineList. <lnil Unit | lcons {List,LineList}>
align@2 match unlabel h with lcons {h,t} -> create@0 lcons ({cons ({x,h}),t})
  hcost: Int
  res: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  new_plan: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  x: Int
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  (2) {x: 0,h: compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))) (Pnil Unit),res: Pnil Unit,hcost: 3,new_plan: compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))} @ {lim: 4} -> compress[0] Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))
  (2) {x: 1,h: compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit),res: Pnil Unit,hcost: 1,new_plan: compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))} @ {lim: 4} -> compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))
  (2) {x: 1,h: compress[0] Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pnil Unit),res: Pnil Unit,hcost: 4,new_plan: compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))} @ {lim: 5} -> compress[0] Lcons (Cons (1) (Cons (3) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))
  (2) {x: 2,h: compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit),res: Pnil Unit,hcost: 2,new_plan: compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))))} @ {lim: 5} -> compress[0] Lcons (Cons (2) (Cons (1) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))
align term #3: compress[0] LineList. <lnil Unit | lcons {List,LineList}>
align@3 create@0 tmp2
  xs: List. <nil Unit | cons {Int,List}>
  tmp2: LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  (3) {xs: Nil Unit,tmp2: Lnil Unit} @ {lim: 0} -> compress[0] Lnil Unit
  (3) {xs: Nil Unit,tmp2: Lnil Unit} @ {lim: 3} -> compress[0] Lnil Unit
  (3) {xs: Nil Unit,tmp2: Lnil Unit} @ {lim: 4} -> compress[0] Lnil Unit
  (3) {xs: Nil Unit,tmp2: Lnil Unit} @ {lim: 5} -> compress[0] Lnil Unit
align term #4: Int
align@4 eval (unlabel h)
  xs: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  t: PlanList. <pnil Unit | pcons {compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>,PlanList}>
  h: compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  (4) {h: compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))),t: Pcons (compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit)),xs: Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Cons (2) (Nil Unit))) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pcons (compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit)))} @ {lim: 4} -> 28
  (4) {h: compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))),t: Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit),xs: Pcons (compress[0] Lcons (Cons (1) (Cons (0) (Nil Unit))) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))) (Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit))} @ {lim: 4} -> 16
  (4) {h: compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (0) (Nil Unit)) (Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pnil Unit)} @ {lim: 4} -> 99
  (4) {h: compress[0] Lnil Unit,t: Pnil Unit,xs: Pcons (compress[0] Lnil Unit) (Pnil Unit)} @ {lim: 3} -> 0
  (4) {h: compress[0] Lcons (Cons (2) (Nil Unit)) (Lnil Unit),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lnil Unit)) (Pnil Unit)} @ {lim: 3} -> 0
  (4) {h: compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Cons (3) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))),t: Pcons (compress[0] Lcons (Cons (2) (Cons (1) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))))) (Pnil Unit)),xs: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Cons (3) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pcons (compress[0] Lcons (Cons (2) (Cons (1) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))))) (Pnil Unit)))} @ {lim: 5} -> 35
  (4) {h: compress[0] Lcons (Cons (2) (Cons (1) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))),t: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))))) (Pnil Unit),xs: Pcons (compress[0] Lcons (Cons (2) (Cons (1) (Nil Unit))) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))) (Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))))) (Pnil Unit))} @ {lim: 5} -> 17
  (4) {h: compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit))))),t: Pnil Unit,xs: Pcons (compress[0] Lcons (Cons (2) (Nil Unit)) (Lcons (Cons (1) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (3) (Nil Unit)) (Lcons (Cons (4) (Nil Unit)) (Lnil Unit)))))) (Pnil Unit)} @ {lim: 5} -> 107
num = 0
start: start
node: start
  Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>([Param0,Param1,Param2,Param3,Param4,Param5]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
  Int([Param0,Param1,Param2,Param3,Param4,Param5]@Int)
node: [Param0,Param1,Param2,Param3,Param4,Param5]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  Param1
node: [Param0,Param1,Param2,Param3,Param4,Param5]@Int
  Param2
  Param5
  +([Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int)
  -([Param0,Param1,Param2,Param3,Param4,Param5]@Int [Param0,Param1,Param2,Param3,Param4,Param5]@Int)
  0
num = 1
start: start
node: start
  Int([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int)
  Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  Param6
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int
  Param0
  Param2
  Param7
  +([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int)
  -([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int)
  0
num = 2
start: start
node: start
  Int([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int)
  Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  Param2
  Param3
node: [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int
  Param0
  Param4
  Param7
  +([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int)
  -([Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int [Param0,Param1,Param2,Param3,Param4,Param5,Param6,Param7]@Int)
  0
num = 3
start: start
node: start
  Int([Param0,Param1,Param2]@Int)
node: [Param0,Param1,Param2]@Int
  Param2
  +([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  -([Param0,Param1,Param2]@Int [Param0,Param1,Param2]@Int)
  0
num = 4
start: start
node: start
  Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>([Param0,Param1,Param2,Param3]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
  Int([Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Compress[0] LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  Param2
node: [Param0,Param1,Param2,Param3]@Int
  Param3
  +([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  -([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  0
  min([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
num = 0
start: start
node: start
  Int([Param0,Param1]@Int)
node: [Param0,Param1]@Int
  Param1
  +([Param0,Param1]@Int [Param0,Param1]@Int)
  -([Param0,Param1]@Int [Param0,Param1]@Int)
  0
  fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int]([Param1]@Int [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int [Param0,Param1]@LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
  min([Param0,Param1]@Int [Param0,Param1]@Int)
  eval([Param0,Param1]@LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
  head_size([Param0,Param1]@LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>)
node: [Param1]@Int
  Param1
  +([Param1]@Int [Param1]@Int)
  -([Param1]@Int [Param1]@Int)
  0
  min([Param1]@Int [Param1]@Int)
node: [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int
  Param1
  Int@0
  +([Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int)
  -([Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int)
  0
  fold[List. <nil Unit | cons {Int,List}>->Int]([Int@0,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@List. <nil Unit | cons {Int,List}>)
  min([Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@Int)
  sum([Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@List. <nil Unit | cons {Int,List}>)
  size([Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@List. <nil Unit | cons {Int,List}>)
  line_cost([Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@List. <nil Unit | cons {Int,List}>)
node: [Int@0,List. <nil Unit | cons {Int,List}>@0,Param1]@List. <nil Unit | cons {Int,List}>
  List. <nil Unit | cons {Int,List}>@0
node: [Int@0,Param1]@Int
  Param1
  Int@0
  +([Int@0,Param1]@Int [Int@0,Param1]@Int)
  -([Int@0,Param1]@Int [Int@0,Param1]@Int)
  0
  min([Int@0,Param1]@Int [Int@0,Param1]@Int)
node: [Int@0,Int@1,Int@2,Param1]@Int
  Param1
  Int@0
  Int@1
  Int@2
  +([Int@0,Int@1,Int@2,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int)
  -([Int@0,Int@1,Int@2,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int)
  0
  min([Int@0,Int@1,Int@2,Param1]@Int [Int@0,Int@1,Int@2,Param1]@Int)
node: [Param0,Param1]@LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>
  Param0

































  [] null
  [0] Param1 -> head_size(Param0)
  [1] Param1 -> eval(Param0)
  [2] Param1 -> fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int](Param1,0,Param0)
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
  [0] head_size(Param0)
  [1] eval(Param0)
  [2] fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int](Param1,0,Param0)
  [0] Param2
  [1] -(Param2,Param7)
  [2] Param6 -> head_size(Param0)
  [3] Param6 -> eval(Param0)
  [4] Param6 -> fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int](Param1,0,Param0)
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
  [0] head_size(Param0)
  [1] eval(Param0)
  [2] fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int](Param1,0,Param0)
  [0] Param0
  [1] Param4
  [2] Param2 -> head_size(Param0)
  [3] Param2 -> eval(Param0)
  [4] Param2 -> fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int](Param1,0,Param0)
  [5] Param3 -> head_size(Param0)
  [6] Param3 -> eval(Param0)
  [7] Param3 -> fold[LineList. <lnil Unit | lcons {List. <nil Unit | cons {Int,List}>,LineList}>->Int](Param1,0,Param0)
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
