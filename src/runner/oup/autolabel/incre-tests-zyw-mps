
List :: List. <nil Unit | cons {Int,List}>
 nil : Unit -> List'. <nil Unit | cons {Int,List'}>
 cons : {Int,List} -> List'. <nil Unit | cons {Int,List'}>
 max : Int -> Int -> Int
spec : List -> Int
snoc : List -> Int -> List'. <nil Unit | cons {Int,List'}>
repr : List -> List
main : List -> Int


Inductive List;

max = \x: Int. \y: Int. 
    if (> x y) then x
    else y;

spec = \xs: List. 
    (fix (
    \f: List -> {Int, Int}. \xs: List. 
    match xs with
      nil _ -> {0, 0}
    | cons {h, t} -> 
        let r = (f t) in 
            {+ h r.1, max 0 (+ h r.2)}
    end
) xs).2;

snoc = fix (
    \f: List -> Int -> List. \xs: List. \w: Int. 
    match xs with
      nil _ -> cons {w, nil Unit}
    | cons {h, t} -> cons {h, f t w}
    end
);

repr = fix (
    \f: Compress List -> List -> Compress List. \pre: Compress List. \xs: List. 
    match xs with
      nil _ -> pre
    | cons {h, t} -> f (align (label (snoc (unlabel pre ) h) ) ) t
    end
) (let tmp1 = (nil Unit) in 
        align (label tmp1 ) );

main = \xs: List. 
    let tmp2 = (repr xs) in 
        align (spec (unlabel tmp2 )) ;
align term #0: compress[0] List
align@0 create@0 snoc (unlabel pre) (h)
  pre: compress[0] List. <nil Unit | cons {Int,List}>
  h: Int
  t: List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
align term #1: compress[0] List. <nil Unit | cons {Int,List}>
align@1 create@0 tmp1
  tmp1: List. <nil Unit | cons {Int,List}>
align term #2: Int
align@2 spec (unlabel tmp2)
  tmp2: compress[0] List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
Components for compress:
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  max [Int,Int] -> Int 1

Components for align:
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  spec [List. <nil Unit | cons {Int,List}>] -> Int 2
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  snoc [List. <nil Unit | cons {Int,List}>,Int] -> List. <nil Unit | cons {Int,List}> 3
  max [Int,Int] -> Int 1

Components for comb:
  cons [(Int * List. <nil Unit | cons {Int,List}>)] -> List. <nil Unit | cons {Int,List}> 0
  nil [Bot] -> List. <nil Unit | cons {Int,List}> 0
  max [Int,Int] -> Int 1

align term #0: compress[0] List
align@0 create@0 snoc (unlabel pre) (h)
  pre: compress[0] List. <nil Unit | cons {Int,List}>
  h: Int
  t: List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
  (0) {h: -3,pre: compress[0] Nil Unit,xs: Cons (-3) (Cons (-1) (Cons (3) (Cons (1) (Cons (3) (Nil Unit))))),t: Cons (-1) (Cons (3) (Cons (1) (Cons (3) (Nil Unit))))} @ {} -> compress[0] Cons (-3) (Nil Unit)
  (0) {h: -1,pre: compress[0] Cons (-3) (Nil Unit),xs: Cons (-1) (Cons (3) (Cons (1) (Cons (3) (Nil Unit)))),t: Cons (3) (Cons (1) (Cons (3) (Nil Unit)))} @ {} -> compress[0] Cons (-3) (Cons (-1) (Nil Unit))
  (0) {h: 3,pre: compress[0] Cons (-3) (Cons (-1) (Nil Unit)),xs: Cons (3) (Cons (1) (Cons (3) (Nil Unit))),t: Cons (1) (Cons (3) (Nil Unit))} @ {} -> compress[0] Cons (-3) (Cons (-1) (Cons (3) (Nil Unit)))
  (0) {h: 1,pre: compress[0] Cons (-3) (Cons (-1) (Cons (3) (Nil Unit))),xs: Cons (1) (Cons (3) (Nil Unit)),t: Cons (3) (Nil Unit)} @ {} -> compress[0] Cons (-3) (Cons (-1) (Cons (3) (Cons (1) (Nil Unit))))
  (0) {h: 3,pre: compress[0] Cons (-3) (Cons (-1) (Cons (3) (Cons (1) (Nil Unit)))),xs: Cons (3) (Nil Unit),t: Nil Unit} @ {} -> compress[0] Cons (-3) (Cons (-1) (Cons (3) (Cons (1) (Cons (3) (Nil Unit)))))
  (0) {h: 5,pre: compress[0] Nil Unit,xs: Cons (5) (Cons (-1) (Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))))))),t: Cons (-1) (Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))))))} @ {} -> compress[0] Cons (5) (Nil Unit)
  (0) {h: -1,pre: compress[0] Cons (5) (Nil Unit),xs: Cons (-1) (Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit))))))),t: Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit))))))} @ {} -> compress[0] Cons (5) (Cons (-1) (Nil Unit))
  (0) {h: 2,pre: compress[0] Cons (5) (Cons (-1) (Nil Unit)),xs: Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))))),t: Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))))} @ {} -> compress[0] Cons (5) (Cons (-1) (Cons (2) (Nil Unit)))
  (0) {h: 5,pre: compress[0] Cons (5) (Cons (-1) (Cons (2) (Nil Unit))),xs: Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit))))),t: Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit))))} @ {} -> compress[0] Cons (5) (Cons (-1) (Cons (2) (Cons (5) (Nil Unit))))
  (0) {h: 4,pre: compress[0] Cons (5) (Cons (-1) (Cons (2) (Cons (5) (Nil Unit)))),xs: Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))),t: Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))} @ {} -> compress[0] Cons (5) (Cons (-1) (Cons (2) (Cons (5) (Cons (4) (Nil Unit)))))
align term #1: compress[0] List. <nil Unit | cons {Int,List}>
align@1 create@0 tmp1
  tmp1: List. <nil Unit | cons {Int,List}>
  (1) {tmp1: Nil Unit} @ {} -> compress[0] Nil Unit
align term #2: Int
align@2 spec (unlabel tmp2)
  tmp2: compress[0] List. <nil Unit | cons {Int,List}>
  xs: List. <nil Unit | cons {Int,List}>
  (2) {tmp2: compress[0] Cons (-3) (Cons (-1) (Cons (3) (Cons (1) (Cons (3) (Nil Unit))))),xs: Cons (-3) (Cons (-1) (Cons (3) (Cons (1) (Cons (3) (Nil Unit)))))} @ {} -> 3
  (2) {tmp2: compress[0] Cons (5) (Cons (-1) (Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit)))))))),xs: Cons (5) (Cons (-1) (Cons (2) (Cons (5) (Cons (4) (Cons (-2) (Cons (-1) (Cons (0) (Nil Unit))))))))} @ {} -> 15
  (2) {tmp2: compress[0] Cons (-4) (Cons (-1) (Cons (4) (Cons (3) (Cons (-3) (Cons (3) (Nil Unit)))))),xs: Cons (-4) (Cons (-1) (Cons (4) (Cons (3) (Cons (-3) (Cons (3) (Nil Unit))))))} @ {} -> 2
  (2) {tmp2: compress[0] Cons (-2) (Cons (-1) (Cons (5) (Cons (-4) (Cons (-2) (Nil Unit))))),xs: Cons (-2) (Cons (-1) (Cons (5) (Cons (-4) (Cons (-2) (Nil Unit)))))} @ {} -> 2
  (2) {tmp2: compress[0] Nil Unit,xs: Nil Unit} @ {} -> 0
  (2) {tmp2: compress[0] Cons (2) (Cons (-5) (Cons (-1) (Cons (-4) (Nil Unit)))),xs: Cons (2) (Cons (-5) (Cons (-1) (Cons (-4) (Nil Unit))))} @ {} -> 2
  (2) {tmp2: compress[0] Cons (-3) (Cons (1) (Cons (-3) (Cons (-3) (Cons (-4) (Nil Unit))))),xs: Cons (-3) (Cons (1) (Cons (-3) (Cons (-3) (Cons (-4) (Nil Unit)))))} @ {} -> 0
  (2) {tmp2: compress[0] Cons (3) (Cons (0) (Cons (-3) (Cons (1) (Nil Unit)))),xs: Cons (3) (Cons (0) (Cons (-3) (Cons (1) (Nil Unit))))} @ {} -> 3
num = 0
start: start
node: start
  Compress[0] List. <nil Unit | cons {Int,List}>([Param0,Param1,Param2,Param3]@Compress[0] List. <nil Unit | cons {Int,List}>)
  Int([Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Int
  Param1
  +([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  -([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
  0
  max([Param0,Param1,Param2,Param3]@Int [Param0,Param1,Param2,Param3]@Int)
node: [Param0,Param1,Param2,Param3]@Compress[0] List. <nil Unit | cons {Int,List}>
  Param0
num = 1
start: start
node: start
  Int([Param0]@Int)
node: [Param0]@Int
  +([Param0]@Int [Param0]@Int)
  -([Param0]@Int [Param0]@Int)
  0
  max([Param0]@Int [Param0]@Int)
num = 2
start: start
node: start
  Compress[0] List. <nil Unit | cons {Int,List}>([Param0,Param1]@Compress[0] List. <nil Unit | cons {Int,List}>)
  Int([Param0,Param1]@Int)
node: [Param0,Param1]@Int
  +([Param0,Param1]@Int [Param0,Param1]@Int)
  -([Param0,Param1]@Int [Param0,Param1]@Int)
  0
  max([Param0,Param1]@Int [Param0,Param1]@Int)
node: [Param0,Param1]@Compress[0] List. <nil Unit | cons {Int,List}>
  Param0
num = 0
start: start
node: start
  Int([Param0]@Int)
node: [Int@0,Int@1]@Int
  Int@0
  Int@1
  +([Int@0,Int@1]@Int [Int@0,Int@1]@Int)
  -([Int@0,Int@1]@Int [Int@0,Int@1]@Int)
  0
  max([Int@0,Int@1]@Int [Int@0,Int@1]@Int)
node: [Param0]@Int
  +([Param0]@Int [Param0]@Int)
  -([Param0]@Int [Param0]@Int)
  0
  fold[List. <nil Unit | cons {Int,List}>->Int]([]@Int [Int@0,Int@1]@Int [Param0]@List. <nil Unit | cons {Int,List}>)
  spec([Param0]@List. <nil Unit | cons {Int,List}>)
  max([Param0]@Int [Param0]@Int)
node: []@Int
  +([]@Int []@Int)
  -([]@Int []@Int)
  0
  max([]@Int []@Int)
node: [Param0]@List. <nil Unit | cons {Int,List}>
  Param0
  snoc([Param0]@List. <nil Unit | cons {Int,List}> [Param0]@Int)















  [0] spec(Param0)
  [1] fold[List. <nil Unit | cons {Int,List}>->Int](0,+(Int@0(),Int@1()),Param0)
  [0] Param1
  [1] Param0 -> spec(Param0)
  [2] Param0 -> fold[List. <nil Unit | cons {Int,List}>->Int](0,+(Int@0(),Int@1()),Param0)
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
  [0] spec(Param0)
  [1] fold[List. <nil Unit | cons {Int,List}>->Int](0,+(Int@0(),Int@1()),Param0)
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
  [] null
  [0] Param0 -> spec(Param0)
  [1] Param0 -> fold[List. <nil Unit | cons {Int,List}>->Int](0,+(Int@0(),Int@1()),Param0)
Academic license - for non-commercial use only - expires 2023-10-17
Academic license - for non-commercial use only - expires 2023-10-17
compress #0: {Int,Int}
pass #0: 
{+ pre.2 (max h (- pre.1 pre.2)), + h pre.2}
pass #1: 
{0, 0}
pass #2: 
tmp2.1

Inductive List;

max = \x: Int. \y: Int. 
    if (> x y) then x
    else y;

spec = \xs: List. 
    (fix (
    \f: List -> {Int, Int}. \xs: List. 
    match xs with
      nil _ -> {0, 0}
    | cons {h, t} -> 
        let r = (f t) in 
            {+ h r.1, max 0 (+ h r.2)}
    end
) xs).2;

snoc = fix (
    \f: List -> Int -> List. \xs: List. \w: Int. 
    match xs with
      nil _ -> cons {w, nil Unit}
    | cons {h, t} -> cons {h, f t w}
    end
);

repr = fix (
    \f: ({Int, Int}) -> List -> {Int, Int}. \pre: {Int, Int}. \xs: List. 
    match xs with
      nil _ -> pre
    | cons {h, t} -> f {+ pre.2 (max h (- pre.1 pre.2)), + h pre.2} t
    end
) {0, 0};

main = \xs: List. 
    let tmp2 = (repr xs) in 
        tmp2.1;
syn-comb: 1.15005
collect: 12.4958
label: 0.014665
extend-component: 0.033257
execute: 4.58913
syn-align: 17.2815
comb-size: 28
align-size: 9
extract-size: 4
18.458
Success
