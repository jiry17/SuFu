
Inductive Tree;

Plan = {Int, Int};

Inductive PlanList;

is_valid_tree = \t: Tree. 
    match t with
      leaf _ -> false
    | node {_, w, leaf _} -> true
    | _ -> false
    end
;

merge = fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
    match xs with
      pnil _ -> ys
    | pcons {h, t} -> pcons {h, f t ys}
    end
);

extend = \l: Plan. \r: Plan. \w: Int. 
    let is_used = (< 0 l.1) in 
        if (is_used) then pcons {{r.1, + r.2 l.2}, pnil Unit}
        else pcons {{+ r.1 w, - (+ r.2 l.2) w}, pcons {{r.1, + r.2 l.2}, pnil Unit}};

extend_all = \w: Int. 
    let extend_one = (\l: Plan. 
    fix (
    \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \pre: PlanList. 
    match xs with
      pnil _ -> pre
    | pcons {h, t} -> merge (extend l h w) (f t pre)
    end
)) in 
        fix (
        \f: PlanList -> PlanList -> PlanList. \xs: PlanList. \ys: PlanList. 
        match xs with
          pnil _ -> pnil Unit
        | pcons {h, t} -> extend_one h ys (f t ys)
        end
    );

generate = fix (
    \f: Tree -> PlanList. \t: Tree. 
    match t with
      leaf _ -> pcons {{0, 0}, pnil Unit}
    | node {w, l, r} -> 
        let lres = (f l) in 
            let rres = (f r) in 
                extend_all w lres rres
    end
);

max = \a: Int. \b: Int. 
    if (< a b) then b
    else a;

get_best = fix (
    \f: PlanList -> Int. \xs: PlanList. 
    match xs with
      pnil _ -> 0
    | pcons {h, t} -> max (* -1 h.2) (f t)
    end
);

main = \t: Tree. 
    if (is_valid_tree t) then get_best (generate t)
    else 0;
