<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Optims (Synduce.Utils.Config.Optims)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Synduce</a> &#x00BB; <a href="../../index.html">Utils</a> &#x00BB; <a href="../index.html">Config</a> &#x00BB; Optims</nav><header class="odoc-preamble"><h1>Module <code><span>Config.Optims</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-turn_off" class="anchored"><a href="#val-turn_off" class="anchor"></a><code><span><span class="keyword">val</span> turn_off : <span><span>bool <span class="xref-unresolved">Base</span>.ref</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-detupling_on" class="anchored"><a href="#val-detupling_on" class="anchor"></a><code><span><span class="keyword">val</span> detupling_on : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Unkmowns of type i -&gt; a * b * c .. are split into i -&gt; a, i -&gt; b and equations between tuples are separated into different equations. Turn off using option -t or --detupling-off</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_syntactic_definitions" class="anchored"><a href="#val-use_syntactic_definitions" class="anchor"></a><code><span><span class="keyword">val</span> use_syntactic_definitions : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Syntactic definitions: detect syntactic definitions in the equation systems and use them. Turn off with --no-syndef</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_rewrite_solver" class="anchored"><a href="#val-use_rewrite_solver" class="anchor"></a><code><span><span class="keyword">val</span> use_rewrite_solver : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Rewrite sovler: find solutions by rewriting expressions and isolate possible solutions for the functions. Turn off with --no-rew</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_partial_correctness_assumption" class="anchored"><a href="#val-make_partial_correctness_assumption" class="anchor"></a><code><span><span class="keyword">val</span> make_partial_correctness_assumption : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Partial correctenss asumptions: don't throw away partial solutions Turn off with --no-assumptions</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_partial_lemma_sketches" class="anchored"><a href="#val-make_partial_lemma_sketches" class="anchor"></a><code><span><span class="keyword">val</span> make_partial_lemma_sketches : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Turn on with --lemma-sketches.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-split_solve_on" class="anchored"><a href="#val-split_solve_on" class="anchor"></a><code><span><span class="keyword">val</span> split_solve_on : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Separate systems of equations into subsystems, and solve independently each subsystem. Use option -s or --split-solving-off to turn off.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-simple_init" class="anchored"><a href="#val-simple_init" class="anchor"></a><code><span><span class="keyword">val</span> simple_init : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Initialize T using a single variable of type theta, instead of searching for a set of terms covering all unknowns. Use option --simple-init or -c to turn on.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bound_after_verif" class="anchored"><a href="#val-bound_after_verif" class="anchor"></a><code><span><span class="keyword">val</span> bound_after_verif : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>In some cases, synthesizing lemmas nca be too hard; the algorithm can revert to bounded mode after a failed round of solution synthesis.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_segis" class="anchored"><a href="#val-use_segis" class="anchor"></a><code><span><span class="keyword">val</span> use_segis : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Not an optimization. Set to true to use the base abstract cegis algorithm. Option --use-segis sets this flag to true.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_cegis" class="anchored"><a href="#val-use_cegis" class="anchor"></a><code><span><span class="keyword">val</span> use_cegis : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Not an optimization. Set to true to use the base concrete cegis algorithm. Option --use-cegis sets this flag to true.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-simplify_eqns" class="anchored"><a href="#val-simplify_eqns" class="anchor"></a><code><span><span class="keyword">val</span> simplify_eqns : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Simplify equations before feeding them to equations solver. Turn off with --no-simplify</p></div></div><div class="odoc-spec"><div class="spec value" id="val-optimize_grammars" class="anchored"><a href="#val-optimize_grammars" class="anchor"></a><code><span><span class="keyword">val</span> optimize_grammars : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Use the equations as a indicator to optimize grammars, without compromising soundness.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_grammar_optimization_level" class="anchored"><a href="#val-set_grammar_optimization_level" class="anchor"></a><code><span><span class="keyword">val</span> set_grammar_optimization_level : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_depth" class="anchored"><a href="#val-expand_depth" class="anchor"></a><code><span><span class="keyword">val</span> expand_depth : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Maximum depth of pointwise expansions to perform. Careful setting this variable to high, it will lead to explosion in the number of terms expanded. A lazy expansion should be implemented.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-num_expansions_check" class="anchored"><a href="#val-num_expansions_check" class="anchor"></a><code><span><span class="keyword">val</span> num_expansions_check : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-expand_cut" class="anchored"><a href="#val-expand_cut" class="anchor"></a><code><span><span class="keyword">val</span> expand_cut : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_num_expansions_check" class="anchored"><a href="#val-set_num_expansions_check" class="anchor"></a><code><span><span class="keyword">val</span> set_num_expansions_check : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>num_expansions_check is set by the -n or --verification option of the CLI.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-use_bmc" class="anchored"><a href="#val-use_bmc" class="anchor"></a><code><span><span class="keyword">val</span> use_bmc : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Use bounded model checking. From CLI, use --use-bmc to set to true.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check_depth" class="anchored"><a href="#val-check_depth" class="anchor"></a><code><span><span class="keyword">val</span> check_depth : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Depth of bounded model checking.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_check_depth" class="anchored"><a href="#val-set_check_depth" class="anchor"></a><code><span><span class="keyword">val</span> set_check_depth : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Bounded model checking depth is set by the -b or --bmc option of the CLI.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-induction_proof_tlimit" class="anchored"><a href="#val-induction_proof_tlimit" class="anchor"></a><code><span><span class="keyword">val</span> induction_proof_tlimit : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>A time limit for induction proofs. Infinity if set to negative.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_induction_proof_tlimit" class="anchored"><a href="#val-set_induction_proof_tlimit" class="anchor"></a><code><span><span class="keyword">val</span> set_induction_proof_tlimit : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-wait_parallel_tlimit" class="anchored"><a href="#val-wait_parallel_tlimit" class="anchor"></a><code><span><span class="keyword">val</span> wait_parallel_tlimit : <span>float <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>A time limit parallel calls when waiting on first result.. Infinity if set to negative. Default is 10 mins.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_wait_parallel_tlimit" class="anchored"><a href="#val-set_wait_parallel_tlimit" class="anchor"></a><code><span><span class="keyword">val</span> set_wait_parallel_tlimit : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rewrite_limit" class="anchored"><a href="#val-rewrite_limit" class="anchor"></a><code><span><span class="keyword">val</span> rewrite_limit : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>A limit for the number of rewriting steps applied during deduction.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_rewrite_limit" class="anchored"><a href="#val-set_rewrite_limit" class="anchor"></a><code><span><span class="keyword">val</span> set_rewrite_limit : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fuzzing_count" class="anchored"><a href="#val-fuzzing_count" class="anchor"></a><code><span><span class="keyword">val</span> fuzzing_count : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>When a model has been found, attempt fuzzing to find models that satisfy the same constraints. Used in Counterexamples.ml.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_fuzzing_count" class="anchored"><a href="#val-set_fuzzing_count" class="anchor"></a><code><span><span class="keyword">val</span> set_fuzzing_count : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-attempt_lifting" class="anchored"><a href="#val-attempt_lifting" class="anchor"></a><code><span><span class="keyword">val</span> attempt_lifting : <span>bool <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>Attempt to lift the function if there is no solution.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-max_lifting_attempts" class="anchored"><a href="#val-max_lifting_attempts" class="anchor"></a><code><span><span class="keyword">val</span> max_lifting_attempts : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>The number of times Synduce should attempt to add a lifting variable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_max_lifting_attempts" class="anchored"><a href="#val-set_max_lifting_attempts" class="anchor"></a><code><span><span class="keyword">val</span> set_max_lifting_attempts : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-max_solutions" class="anchored"><a href="#val-max_solutions" class="anchor"></a><code><span><span class="keyword">val</span> max_solutions : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>The maximum number of different solutions Synduce attempts to find. If set to (-1), Synduce only attempt to solve the given skeleton.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_max_solutions" class="anchored"><a href="#val-set_max_solutions" class="anchor"></a><code><span><span class="keyword">val</span> set_max_solutions : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Set the maximum number of solutions. The string argument must represent a number between 1 and 32.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rstar_limit" class="anchored"><a href="#val-rstar_limit" class="anchor"></a><code><span><span class="keyword">val</span> rstar_limit : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div><div class="spec-doc"><p>The number of expansions an algorithm goes through to identify an algorithm run.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_rstar_limit" class="anchored"><a href="#val-set_rstar_limit" class="anchor"></a><code><span><span class="keyword">val</span> set_rstar_limit : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div><div class="spec-doc"><p>Set the number of expansions the algorithm uses to identify an algorithm run.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-some_eager_optim_on" class="anchored"><a href="#val-some_eager_optim_on" class="anchor"></a><code><span><span class="keyword">val</span> some_eager_optim_on : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-turn_off_eager_optims" class="anchored"><a href="#val-turn_off_eager_optims" class="anchor"></a><code><span><span class="keyword">val</span> turn_off_eager_optims : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-num_threads" class="anchored"><a href="#val-num_threads" class="anchor"></a><code><span><span class="keyword">val</span> num_threads : <span>int <span class="xref-unresolved">Base</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-set_num_threads" class="anchored"><a href="#val-set_num_threads" class="anchor"></a><code><span><span class="keyword">val</span> set_num_threads : <span><span class="xref-unresolved">Base</span>.string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Base</span>.unit</span></code></div></div></div></body></html>